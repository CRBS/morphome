# Amira Project 600
# Amira
# Generated by morphOME (https://github.com/slash-segmentation/morphome)

###
#####
# HARD-CODED INPUT VALUES
#####
###

set fname "<FILENAME>"
set pathOut "<PATH_OUT>"
set scale [list <SCALE>]

set scalex [lindex $scale 0]
set scaley [lindex $scale 1]
set scalez [lindex $scale 2]

###
#####
# DATA IMPORT
#####
###

# Extract the VRML file's basename
set base [file tail $fname]
set base [string trimright $base ".wrl"]

# Load the VRML file into Amira
[load $fname] setLabel $base

# Convert VRML to surface (named "GeometrySurface")
set module "Open Inventor Scene To Surface"
create HxGeometryToSurface $module
$module data connect $base
$module action snap
$module fire

# Remesh the surface. The surface is remeshed using the best isotropic vertex
# placement and the same number of output triangles.
set module "Remesh Surface"
set nTriIn ["GeometrySurface" getNumTriangles]
set nTriOut $nTriIn
create HxRemeshSurface $module
$module select
$module data connect "GeometrySurface"
$module fire
$module objective setIndex 0 1 
$module interpolateOrigSurface setValue 0
$module desiredSize setValue 1 $nTriOut
$module remeshOptions1 setValue 0 0 
$module remeshOptions1 setValue 1 1 
$module fire
$module remesh snap
$module fire

# Smooth the remeshed surface with the input parameters.
set module "Smooth Surface"
create HxSurfaceSmooth $module
$module data connect "GeometrySurface.remeshed"
$module parameters setValue 0 10
$module parameters setValue 1 0.6
$module action snap
$module fire

###
#####
# 3D BINARY IMAGE METRICS
#####
###

# Convert the surface to a binary volume stack. First, the dimensions of the
# output stack need to be set. If the default dimensions aren't changed, Amira
# will try to output a stack requiring petabytes of memory.
set module "Scan Surface To Volume"
create HxScanConvertSurface $module
$module data connect "GeometrySurface.smooth"
$module field disconnect
$module fire
set xmin [$module bbox getValue 0]
set xmax [$module bbox getValue 1]
set ymin [$module bbox getValue 2]
set ymax [$module bbox getValue 3]
set zmin [$module bbox getValue 4]
set zmax [$module bbox getValue 5]
set dimx [expr round((double($xmax) / $scalex - double($xmin) / $scalex))]
set dimy [expr round((double($ymax) / $scaley - double($ymin) / $scaley))]
set dimz [expr round((double($zmax) / $scalez - double($zmin) / $scalez))]
$module dimensions setValues $dimx $dimy $dimz
$module action snap
$module fire
"GeometrySurface.scanConverted" sharedColormap setValue "grayScale.am"
"GeometrySurface.scanConverted" sharedColormap setMinMax 0 1
"GeometrySurface.scanConverted" ImageData disconnect
"GeometrySurface.scanConverted" fire
"GeometrySurface.scanConverted" primary setIndex 0 0
"GeometrySurface.scanConverted" fire
"GeometrySurface.scanConverted" select
"GeometrySurface.scanConverted" VoxelSize setValue "$scalex x $scaley x $scalez"

# Label analysis
set module "Label Analysis"
create HxAnalyzeLabels $module
$module data connect "GeometrySurface.scanConverted"
$module measures setState "Mitochondrion" Anisotropy BaryCenterX BaryCenterY \
    BaryCenterZ CroftonPerimeter Elongation Euler3D EqDiameter FeretShape3d \
    Flatness Shape_VA3d OrientationPhi OrientationTheta
$module interpretation setValue 0
$module doIt hit 
$module fire

###
#####
# 3D SKELETONIZATION VIA TEASAR ALGORITHM
#####
###

# Compute skeleton
set module "Centerline Tree"
create HxTEASAR $module
$module data connect "GeometrySurface.scanConverted"
$module doIt snap
$module fire

# Smooth the skeleton
set module "Smooth Tree"
create HxSmoothLine $module
$module lineSet connect "GeometrySurface.spatialgraph"
$module coefficients setValue 0 $smooth
$module coefficients setValue 1 $attach
$module numberOfIterations setValue $iter
$module doIt snap
$module fire

###
#####
## DATA EXPORT
#####
###

## Export files to disk for further analysis
#set fname_gradient [file join $pathOut ${base}_gradient.am]
#set fname_shapeindex [file join $pathOut ${base}_shapeindex.am]
#set fname_surface [file join $pathOut ${base}_surface.surf]
#set fname_convhull [file join $pathOut ${base}_convhull.surf]
#set fname_labelcsv [file join $pathOut ${base}_label.csv]
#set fname_savcsv_nuc [file join $pathOut ${base}_sav_nuc.csv]
#set fname_savcsv_ch [file join $pathOut ${base}_sav_ch.csv]
#set fname_meancurv [file join $pathOut ${base}_meancurv.am]
#set fname_gausscurv [file join $pathOut ${base}_gausscurv.am]
#
#"Result" exportData "Amira ASCII" $fname_gradient
#"ShapeIndex" exportData "Amira ASCII" $fname_shapeindex
#"MeanCurvature" exportData "Amira ASCII" $fname_meancurv
#"GaussCurvature" exportData "Amira ASCII" $fname_gausscurv
#"GeometrySurface.smooth" exportData "HxSurface ASCII" $fname_surface
#"GeometrySurface-convexHull" exportData "HxSurface ASCII" $fname_convhull
#"GeometrySurface.Label-Analysis" exportData "CSV" $fname_labelcsv
#"GeometrySurface.statistics" exportData "CSV" $fname_savcsv_nuc
#"GeometrySurface-convexHull.statistics" exportData "CSV" $fname_savcsv_ch
#
#exit
