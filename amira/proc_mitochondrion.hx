# Amira Project 600
# Amira
# Generated by morphOME (https://github.com/crbs/morphome)

proc makeCameraOrbitEvent {type time1 time2 angle1 angle2} {
    # Generates a single classic Demo Maker event string that performs rotation
    # of an object by a specified number of degrees across a given time 
    # interval.
    #
    # Inputs
    # ------
    # type     String specifying the object type (i.e. "Camera-Orbit").
    # time1    Time to begin the rotation.
    # time2    Time to end the rotation (in seconds).
    # angle1   Angle to begin the rotation at (in degrees).
    # angle2   Angle to end the rotation at.
    #
    # Returns
    # -------
    # str      Classic Demo Maker event string specifying the desired rotation.
    set str "dummy {numeric {$type/Time} $time1 $time2 $angle1 $angle2 0 360 "
    append str "{\"$type\" time setValue %0%; \"$type\" fire}} "
    return $str
}

###
#####
# HARD-CODED INPUT VALUES
#####
###

set fname "<FILENAME>"
set pathOut "<PATH_OUT>"
set displayOn "<DISPLAY>"
set scale [list <SCALE>]
set scalex [lindex $scale 0]
set scaley [lindex $scale 1]
set scalez [lindex $scale 2]

###
#####
# DATA IMPORT
#####
###

global base AMIRA_ROOT

# Extract the VRML file's basename
set base [file tail $fname]
set base [string trimright $base ".wrl"]

# Load the VRML file into Amira
[load $fname] setLabel $base

# Convert VRML to surface (named "GeometrySurface")
set module "Open Inventor Scene To Surface"
create HxGeometryToSurface $module
$module data connect $base
$module action snap
$module fire

###
#####
# REMESHING & SMOOTHING
#####
###

# Remesh the surface. The surface is remeshed using the best isotropic vertex
# placement and the same number of output triangles.
set module "Remesh Surface"
set nTriIn ["GeometrySurface" getNumTriangles]
set nTriOut $nTriIn
create HxRemeshSurface $module
$module select
$module data connect "GeometrySurface"
$module fire
$module objective setIndex 0 1 
$module interpolateOrigSurface setValue 0
$module desiredSize setValue 1 $nTriOut
$module remeshOptions1 setValue 0 0 
$module remeshOptions1 setValue 1 1 
$module fire
$module remesh snap
$module fire

# Smooth the remeshed surface with the input parameters.
set module "Smooth Surface"
create HxSurfaceSmooth $module
$module data connect "GeometrySurface.remeshed"
$module parameters setValue 0 <SURFACE_SMOOTH_ITERATIONS>
$module parameters setValue 1 <SURFACE_SMOOTH_LAMBDA>
$module action snap
$module fire

###
#####
# VOLUME & SURFACE AREA
#####
###

# Get surface area and volume of the mito
set module "Surface Area Volume Mito"
create HxSurfaceArea $module
$module data connect "GeometrySurface.smooth"
$module doIt snap
$module fire

###
#####
# 3D BINARY IMAGE METRICS
#####
###

# Convert the surface to a binary volume stack. First, the dimensions of the
# output stack need to be set. If the default dimensions aren't changed, Amira
# will try to output a stack requiring petabytes of memory.
set module "Scan Surface To Volume"
create HxScanConvertSurface $module
$module data connect "GeometrySurface.smooth"
$module field disconnect
$module fire
set xmin [$module bbox getValue 0]
set xmax [$module bbox getValue 1]
set ymin [$module bbox getValue 2]
set ymax [$module bbox getValue 3]
set zmin [$module bbox getValue 4]
set zmax [$module bbox getValue 5]
set dimx [expr round((double($xmax) / $scalex - double($xmin) / $scalex))]
set dimy [expr round((double($ymax) / $scaley - double($ymin) / $scaley))]
set dimz [expr round((double($zmax) / $scalez - double($zmin) / $scalez))]
$module dimensions setValues $dimx $dimy $dimz
$module action snap
$module fire
"GeometrySurface.scanConverted" sharedColormap setValue "grayScale.am"
"GeometrySurface.scanConverted" sharedColormap setMinMax 0 1
"GeometrySurface.scanConverted" ImageData disconnect
"GeometrySurface.scanConverted" fire
"GeometrySurface.scanConverted" primary setIndex 0 0
"GeometrySurface.scanConverted" fire
"GeometrySurface.scanConverted" select
"GeometrySurface.scanConverted" VoxelSize setValue "$scalex x $scaley x $scalez"

# Label analysis
set module "Label Analysis"
create HxAnalyzeLabels $module
$module data connect "GeometrySurface.scanConverted"
$module measures setState "Mitochondrion" Anisotropy BaryCenterX BaryCenterY \
    BaryCenterZ CroftonPerimeter Elongation Euler3D EqDiameter FeretShape3d \
    Flatness Shape_VA3d OrientationPhi OrientationTheta
$module interpretation setValue 0
$module doIt hit 
$module fire

###
#####
# BRANCH ANALYSIS VIA TEASAR SKELETONIZATION ALGORITHM
#####
###

# Compute skeleton
set module "Centerline Tree"
create HxTEASAR $module
$module data connect "GeometrySurface.scanConverted"
$module doIt snap
$module fire

# Smooth the skeleton
set module "Smooth Tree"
create HxSmoothLine $module
$module lineSet connect "GeometrySurface.Spatial-Graph"
$module coefficients setValue 0 <SKELETON_SMOOTH_COEFFICIENT1>
$module coefficients setValue 1 <SKELETON_SMOOTH_COEFFICIENT2>
$module numberOfIterations setValue <SKELETON_SMOOTH_ITERATIONS>
$module doIt snap
$module fire

# Get branch length statistics
set module "Spatial Graph Statistics"
create HxSpatialGraphStats $module
$module data connect "SmoothTree.spatialgraph"
$module doIt snap
$module fire

###
#####
## DATA EXPORT
#####
###

# Export files to disk for further analysis
set fname_savcsv [file join $pathOut ${base}_sav.csv]
set fname_labelcsv [file join $pathOut ${base}_label.csv]
set fname_lengthcsv [file join $pathOut ${base}_length.csv]
set fname_nodes [file join $pathOut ${base}_nodes.am]

"GeometrySurface.statistics" exportData "CSV" $fname_savcsv
"GeometrySurface.Label-Analysis" exportData "CSV" $fname_labelcsv
"SmoothTree.statistics" exportData "CSV" $fname_lengthcsv
"SmoothTree.spatialgraph" exportData "AmiraMesh ascii SpatialGraph" $fname_nodes

###
#####
## DISPLAY
#####
##

if {$displayOn} {
    # Set background to solid black
    viewer 0 setBackgroundMode 0
    viewer 0 setBackgroundColor 0 0 0    

    # Set up display of the surface
    set module "Surface View"
    create HxDisplaySurface $module
    $module data connect "GeometrySurface.smooth"
    $module drawStyle setValue 4
    $module drawStyle setNormalBinding 1
    $module colorMode setValue 5
    $module colormap setDefaultColor <SURFACE_RED> <SURFACE_GREEN> <SURFACE_BLUE>
    $module baseTrans setValue 0.8
    $module fire

    # Set up display of the skeleton
    set module "Spatial Graph View"
    create HxSpatialGraphView $module
    $module data connect "SmoothTree.spatialgraph"
    $module nodeScaleFactor setMinMax 0 $scalex
    $module nodeScaleFactor setValue $scalex
    $module nodeColor setColor 0 <NODE_RED> <NODE_GREEN> <NODE_BLUE>
    $module segmentWidth setMinMax 0 <SKELETON_WIDTH>
    $module segmentWidth setValue <SKELETON_WIDTH>
    $module fire

    # Create camera path, rotating once around the object
    set module "Camera-Orbit"
    create HxCircularCameraPath $module
    $module action setState menus 1 4
    $module fire

    # Setup Demo Maker
    set movieLength 4
    set movieEventString [makeCameraOrbitEvent "Camera-Orbit" 0 4 0 360]
    echo $movieEventString
    set scriptAnim [load ${AMIRA_ROOT}/share/script-objects/DemoMakerClassic.scro]
    set scriptAnim [lindex $module 0]
    $scriptAnim setVar scroTypeDemoMaker 1
    $scriptAnim setVar "internalEventList" $movieEventString
    $scriptAnim setVar "lastStartTime" 0
    $scriptAnim setVar "lastEndTime" $movieLength
    $scriptAnim setVar "lastTimeStep" 0
    $scriptAnim setVar "loadNetwDemoMakers" {}
    $scriptAnim fire
    $scriptAnim time disconnect
    $scriptAnim time setMinMax 0 $movieLength
    $scriptAnim time setSubMinMax 0 $movieLength
    $scriptAnim time setValue 1
    $scriptAnim time setValue 0
    $scriptAnim time animationMode -once
    $scriptAnim fire
    $scriptAnim select
    
    # Create Movie Maker module
    set module "Movie Maker"
    create HxMovieMaker $module
    $module time connect $scriptAnim
    $module fire
    $module fileFormat setValue 2
    $module frameRate setValue 0
    $module frames setValue 18
    $module compressionQuality setValue 1
    $module size setValue 5
    $module resolution setValue 0 500
    $module resolution setValue 1 500
    $module filename setValue $pathOut/mov
    $module action setState index 0
    $module action touch 0
    $module fire
    echo $fname
    echo $pathOut
}

exit
